generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model bookings {
  id                   Int             @id @default(autoincrement())
  rideId               Int
  riderId              Int
  confirmationNumber   String          @unique
  pickupAddress        String
  pickupCity           String?
  pickupState          String?
  pickupZipCode        String?
  pickupLatitude       Float
  pickupLongitude      Float
  status               String          @default("pending")
  createdAt            DateTime        @default(now())
  updatedAt            DateTime        @updatedAt
  numberOfSeats        Int             @default(1)
  pickupStatus         String          @default("pending")
  pickedUpAt           DateTime?
  pickupPinHash        String?
  pickupPinEncrypted   String?
  pickupPinExpiresAt   DateTime?
  pickupPinAttempts    Int             @default(0)
  pickupPinLockedUntil DateTime?
  paymentIntentId     String?
  rides                rides           @relation(fields: [rideId], references: [id], onDelete: Cascade)
  users                users           @relation(fields: [riderId], references: [id], onDelete: Cascade)
  notifications        notifications[]
  messages             messages[]
  ratings              ratings[]
}

model notifications {
  id                                  Int       @id @default(autoincrement())
  driverId                            Int?
  type                                String
  title                               String
  message                             String
  bookingId                           Int?
  rideId                              Int?
  isRead                              Boolean   @default(false)
  createdAt                           DateTime  @default(now())
  updatedAt                           DateTime  @updatedAt
  riderId                             Int?
  bookings                            bookings? @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  users_notifications_driverIdTousers users?    @relation("notifications_driverIdTousers", fields: [driverId], references: [id], onDelete: Cascade)
  rides                               rides?    @relation(fields: [rideId], references: [id], onDelete: Cascade)
  users_notifications_riderIdTousers  users?    @relation("notifications_riderIdTousers", fields: [riderId], references: [id], onDelete: Cascade)
}

model rides {
  id                   Int             @id @default(autoincrement())
  driverId             Int
  driverName           String
  driverPhone          String
  carMake              String?
  carModel             String?
  carYear              Int?
  carColor             String?
  fromAddress          String
  fromCity             String
  fromState            String
  fromZipCode          String
  fromLatitude         Float
  fromLongitude        Float
  toAddress            String
  toCity               String
  toState              String
  toZipCode            String
  toLatitude           Float
  toLongitude          Float
  departureDate        String
  departureTime        String
  totalSeats           Int             @default(1)
  availableSeats       Int
  pricePerSeat         Float
  distance             Float?
  status               String          @default("scheduled")
  createdAt            DateTime        @default(now())
  updatedAt            DateTime        @updatedAt
  totalEarnings        Float?
  estimatedTimeMinutes Int?
  isRecurring          Boolean         @default(false)
  recurringPattern     String?
  recurringEndDate     String?
  parentRideId         Int?
  isDraft              Boolean         @default(false)
  bookings             bookings[]
  notifications        notifications[]
  messages             messages[]
  ratings              ratings[]
  users                users           @relation(fields: [driverId], references: [id], onDelete: Cascade)
  rides                rides?          @relation("ridesTorides", fields: [parentRideId], references: [id])
  other_rides          rides[]         @relation("ridesTorides")
}

model users {
  id                                          Int             @id @default(autoincrement())
  fullName                                    String
  email                                       String          @unique
  phoneNumber                                 String
  password                                    String
  createdAt                                   DateTime        @default(now())
  updatedAt                                   DateTime        @updatedAt
  city                                        String?
  photoUrl                                    String?
  carColor                                    String?
  carMake                                     String?
  carModel                                    String?
  carYear                                     Int?
  isDriver                                    Boolean         @default(false)
  isRider                                     Boolean         @default(false)
  lastLocationLatitude                        Float?
  lastLocationLongitude                       Float?
  lastLocationUpdate                          DateTime?
  notifyBookings                              Boolean         @default(true)
  notifyMessages                              Boolean         @default(true)
  notifyRideUpdates                           Boolean         @default(true)
  notifyPromotions                            Boolean         @default(true)
  shareLocationEnabled                        Boolean         @default(true)
  pushToken                                   String?
  pushTokenType                               String?
  pushTokenPlatform                           String?
  pushTokenDeviceId                           String?
  pushTokenUpdatedAt                          DateTime?
  // Stripe Connect fields for driver payouts
  stripeAccountId                             String?         @unique
  stripeAccountStatus                         String?         // 'pending', 'restricted', 'enabled', 'disabled'
  stripeOnboardingStatus                      String?         @default("not_started") // 'not_started' | 'pending' | 'verified' | 'restricted'
  stripeRequirementsDue                        Json?          // Cache for UI (currently_due, eventually_due, past_due)
  bankAccountId                               String?         // Stripe bank account ID
  bankAccountLast4                            String?         // Last 4 digits of bank account
  bankAccountType                             String?         // 'checking' or 'savings'
  bankAccountStatus                            String?         // 'new', 'validated', 'verified', 'errored'
  payoutsEnabled                              Boolean         @default(false)
  emailVerified                               Boolean         @default(false)
  bookings                                    bookings[]
  notifications_notifications_driverIdTousers notifications[] @relation("notifications_driverIdTousers")
  notifications_notifications_riderIdTousers  notifications[] @relation("notifications_riderIdTousers")
  rides                                       rides[]
  messages_sent                               messages[]      @relation("messages_sender")
  messages_received                           messages[]      @relation("messages_receiver")
  ratings_given                               ratings[]       @relation("ratings_rater")
  ratings_received                            ratings[]       @relation("ratings_rated")
  payouts                                     payouts[]
}

model messages {
  id          Int      @id @default(autoincrement())
  senderId    Int
  receiverId  Int
  rideId      Int?
  bookingId   Int?
  message     String
  isRead      Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  sender      users    @relation("messages_sender", fields: [senderId], references: [id], onDelete: Cascade)
  receiver    users    @relation("messages_receiver", fields: [receiverId], references: [id], onDelete: Cascade)
  rides       rides?   @relation(fields: [rideId], references: [id], onDelete: Cascade)
  bookings    bookings? @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  @@index([senderId, receiverId])
  @@index([receiverId, isRead])
  @@map("messages")
}

model ratings {
  id            Int       @id @default(autoincrement())
  rideId        Int
  bookingId     Int?
  raterId       Int       // User who gave the rating (driver or rider)
  ratedUserId   Int       // User who received the rating
  rating        Int       // 1-5 stars
  feedback      String?   // Optional text feedback
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  rides         rides     @relation(fields: [rideId], references: [id], onDelete: Cascade)
  bookings      bookings? @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  rater         users     @relation("ratings_rater", fields: [raterId], references: [id], onDelete: Cascade)
  ratedUser     users     @relation("ratings_rated", fields: [ratedUserId], references: [id], onDelete: Cascade)

  @@index([ratedUserId])
  @@index([rideId])
  @@index([rideId, bookingId, raterId])
  @@map("ratings")
}

model payouts {
  id                    Int       @id @default(autoincrement())
  driverId              Int
  stripePayoutId        String?   @unique
  amount                Float     // Amount in dollars (net earnings)
  currency              String    @default("usd")
  status                String    // 'pending', 'processing', 'paid', 'failed', 'canceled'
  payoutMethod          String    @default("bank_account") // 'bank_account'
  description           String?
  failureCode           String?
  failureMessage        String?
  arrivalDate           DateTime? // When funds will arrive
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  users                 users     @relation(fields: [driverId], references: [id], onDelete: Cascade)

  @@index([driverId])
  @@index([status])
  @@index([createdAt])
  @@map("payouts")
}

model emailVerificationCodes {
  id         Int      @id @default(autoincrement())
  email      String   @unique
  code       String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([email])
  @@index([expiresAt])
  @@map("emailVerificationCodes")
}
